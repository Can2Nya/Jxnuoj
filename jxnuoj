#!/usr/bin/env python

"""
coded by fookwood
parameters are passed like this:
$ ./onj 1.cpp 1002 1000 32767
argv[1] : the source code that will be compiled
argv[2] : the problem number
argv[3] : the time limit
argv[4] : the memory limit
"""

import sys, signal, os, subprocess, syslog, time,string

PROBLEMDIR = 'problems'
# CODEDIR = 'codes'

# Verdicts
verdict = { 'ACCEPTED' : 0 ,'WA' : 1,'TLE' : 2,'MLE' : 3,'RE' : 4,'CE' : 5,'OLE' : 6,'ILE' : 7,'PE' : 8 }

TIME_LIMIT = string.atoi(sys.argv[3],10)
# TIME_LIMIT = int(sys.argv[3])
MEMORY_LIMIT = int(sys.argv[4])

def debug(msg):
	print msg
	syslog.syslog(msg)

# check if two files are the same
def file_same(a,b):

	fileA = open(a,'r')
	fileB = open(b,'r')
	value = False
	fa=fileA.read()
	fb=fileB.read()
	fa=fa.replace('\r','')
	fb=fb.replace('\r','')
	if fa == fb:
		value=True
	# if fileA.readlines() == fileB.readlines():
	# 	value = True
	fileA.close()
	fileB.close()


	return value
def old_file_same(a, b):
	fileA = open(a, "r")
	fileB = open(b, "r")

	linesA = fileA.readlines()
	linesB = fileB.readlines()

	fileA.close()
	fileB.close()

	if(len(linesA) != len(linesB)):
		return False

	for i in range(0, len(linesA)):
		lineA = linesA[i].strip()
		lineB = linesB[i].strip()
		if(lineA != lineB):
			return False

	return True
# if two files are almost the same
def compare_files(a,b):
	fileA = open(a,'r')
	fileB = open(b,'r')

	linesA = str(fileA.read())
	linesB = str(fileB.read())
	sa=linesA
	sb=linesB
	sa = sa.replace('\r', '')
	sa = sa.replace('\n','')
	sa = sa.replace('\t', '')
	sa = sa.replace(' ', '')
	sb = sb.replace('\r', '')
	sb = sb.replace('\n', '')
	sb = sb.replace('\t', '')
	sb = sb.replace(' ', '')
	fileA.close()
	fileB.close()
	# debug("A = \n" + linesA)
	# debug("B = \n" + linesB)
	if sa == sb:

		debug("file is same")
		return True
	debug("file not same")
	return False

# Parse commandlines options
# //for example $destFile="problems/wuying/1000_1.cpp"
sourcefile = sys.argv[1]
debug("sourcefile"+sourcefile)
problem = sys.argv[2]
# path = "."+os.sep+"tmp"
# ext = sourcefile.split(".")[1]
path = "/".join(sourcefile.split("/")[:-1])
ext = sourcefile.split(".")[1]
# runid = sourcefile.split(".")[0]
"""
print sourcefile	1.cpp
print problem		1001
print path			./tmp
print ext			cpp
"""
# check if the code is too long
# a = open(CODEDIR+os.sep+sourcefile,"r")
a = open(sourcefile,"r")
codecode = a.read()
a.close()
if len(codecode) >= 50000:
	debug("ILE")
	sys.exit(verdict["ILE"])

if ext == "cpp":
	compile = "g++ -lm %s -o %s 2> /dev/null" % (sourcefile, path + "/a.out")
elif ext  == "c":
	compile = "gcc -lm %s -o %s 2> /dev/null" % (sourcefile, path + "/a.out")

if os.system(compile):
	debug("CE")
	sys.exit(verdict["CE"])

# run = path+os.sep+runid
# infile = PROBLEMDIR + os.sep + problem + os.sep + problem + ".IN"
# outfile= path+os.sep+runid+".OUT"

file = sourcefile.split("/")[-1]
infile = PROBLEMDIR + "/" + problem + "/in"
outfile = path + "/op"
runid = "./a.out"
debug(infile)
debug(outfile)
# Run
debug("Running...")
p = subprocess.Popen( runid,stdin=open(infile,"r"),stdout=open(outfile,"w"),stderr=open("/dev/null","w"),cwd=path)
start = time.time()
while p.poll() == None:
	# s = file("/proc/"+str(p.pid)+"/status",'r').read()
	s=open("/proc/"+str(p.pid)+"/status").read()
	if s.find('RSS') <0:
		continue
	s=s[s.find('RSS')+6:]
	s=s[:s.find('kB')-1]
	mm = int(s)
	if mm > MEMORY_LIMIT:
		p.kill()
		debug("MLE")
		sys.exit(verdict["MLE"])
	tt = int((time.time()-start)*1000)
	if tt > TIME_LIMIT:
		p.kill()
		debug("TLE")
		sys.exit(verdict["TLE"])

print "time cost:"+str(tt)+"ms";
print "mem  cost:"+str(mm)+"kb"
r = p.returncode
debug("Exit status : %d " % r )
if r != 0:
	debug("RE")
	sys.exit(verdict["RE"])

# compare output with expected out
# outputProduced = outfile
# outputExpected = PROBLEMDIR + os.sep + problem + os.sep + problem + ".OUT"
outputProduced = path + "/op"
outputExpected = PROBLEMDIR + "/" + problem + "/out"
debug(outputProduced)
debug(outputExpected)
a = open(outfile,'r')
codecode = a.read()
if len(codecode) >= 50000:
	debug( "OLE")
	sys.exit(verdict["OLE"] )

timefile= open(path+os.sep+problem+".TIME","w")
memfile = open(path+os.sep+problem+".MEM","w")
timefile.write(str(tt))
memfile.write(str(mm))
timefile.close()
memfile.close()

# if compare_files(outputProduced,outputExpected) == True:
# 	if file_same(outputProduced,outputExpected) == True:
# 		debug("AC")
# 		sys.exit( verdict["ACCEPTED"] )
# 	else:
# 		debug("PE")
# 		sys.exit( verdict["PE"] )
# else:
# 	debug("WA")
# 	sys.exit(verdict["WA"])
debug("start judge")
if file_same(outputProduced,outputExpected) == True:
	debug("AC")
	sys.exit(verdict["ACCEPTED"])
else :

	if compare_files(outputProduced,outputExpected) == True:
		debug("PE")
		sys.exit(verdict["PE"])
	else:
		debug("WA")
		sys.exit(verdict["WA"])